
<!DOCTYPE HTML>
<body>
	<script>
/*
//Stacks
	function Stack(arr_)
	{
	 this.arr=[];
	 if(arr_)
	   this.arr=arr_;
	}
	
	Stack.prototype.isEmpty=function()
	{
	  return(Boolean(!(this.arr.length)));
	}
	Stack.prototype.getBuffer=function()
	{
	  return (this.arr.slice());
	}
 
	Stack.prototype.push=function(value)
	{
	  this.arr.push(value);
	}
	Stack.prototype.peek=function()
	{
	  return(console.log(this.arr[this.arr.length-1]));
	}
	
	Stack.prototype.pop=function()
	{
	  return(this.arr.pop());
	}
	function Access(stack,n)
	{
	  let bufferStack=new Stack(stack.getBuffer());
	  while(--n!=0)
		bufferStack.pop();
	  return bufferStack.pop();
	}
	function Search(stack,element)
	{
	  let bufferStack=new Stack(stack.getBuffer());
	  while(bufferStack.isEmpty())
	  {
	    if(element==bufferStack.pop())
	    {
	       return true;
	    }
	  }
	  return false;
	}
	let stk=new Stack();
	stk.push(5);			// arr=[5]
	stk.push(6);			// arr=[5,6]
	stk.pop();			// arr=[5]
	stk.push(7);			// arr=[5,7]
	stk.push(8);			// arr=[5,7,8]
	stk.push(9);			// arr=[5,7,8,9]
	stk.push(10);			// arr=[5,7,8,9,10]
	console.log(stk.isEmpty());	// returns false
	console.log(Access(stk,2));	// returns 9
	console.log(Search(stk,21));	// returns false
*/

/*
	//Queue
	function Queue(arr_)
	{
	  this.arr=[];
	  if(arr_)
	    this.arr=arr_;
	}
	Queue.prototype.getBuffer=function()
	{
	  return this.arr.slice();
	}
	Queue.prototype.isEmpty=function()
	{
	  return (Boolean(!(this.arr.length)));
	}
	Queue.prototype.enque=function(value)
	{
	  this.arr.push(value);
	}
	Queue.prototype.deque=function()
	{
	  return this.arr.shift();
	}
	Queue.prototype.peek=function()
	{
          return this.arr[0];
	}
	function queueNAccess(queue,n)
	{
	  let bufferQueue=new Queue(queue.getBuffer());
	  while(--n!=0)
		bufferQueue.deque();
	  return bufferQueue.deque();
	}
	function queueSearch(queue,element)
	{
	  let bufferQueue=new Queue(queue.getBuffer());
	  while(!(bufferQueue.isEmpty()))
	  {
	    if(element==bufferQueue.deque())
		  return true;
	  }
	  return false;
	}
	let Q=new Queue();
	Q.enque(1);                     // arr=[1]
	Q.enque(2);			// arr=[1,2]
	Q.enque(3);			// arr=[1,2,3]
	Q.enque(4);			// arr=[1,2,3,4]
	Q.enque(5);			// arr=[1,2,3,4,5]
	Q.enque(6);			// arr=[1,2,3,4,5,6]
	Q.deque();			// arr=[2,3,4,5,6]
	console.log(Q.isEmpty());	// returns false		
	console.log(Q.peek());		// returns '2'
	console.log(queueSearch(Q,9));	// returns false
	console.log(queueNAccess(Q,2)); // returns '3'
*/

/*
	//Implementation of singlyLinkedList
	function singleLinkedListNode(val)
	{//element must always have a next ptr & head!
		this.head=val;
		this.next=null;
	}
	function singleLinkedList()
	{
		this.head=null;
		this.size=0;
	}
	var sll=new singleLinkedList();
	singleLinkedList.prototype.insert=function(val)
		      {
			if(this.head==null)
			      this.head=new singleLinkedListNode(val);
			else
			    {
			      let temp=this.head;
			      this.head=new singleLinkedListNode(val);
			      this.head.next=temp;
			    }
			this.size++;
		      }
       
       singleLinkedList.prototype.deletion=
	function(val)
	{
	 let currentHead=this.head;
	 if(currentHead.head==val)
	 {
	  this.head=currentHead.next;
	  this.size--;
	 }
	 else
	 {
	    let prev=currentHead;
	    while(currentHead.next)
	    {
	     if(currentHead.head==val)
	     {
		prev.next=currentHead.next;
		prev=currentHead;
		currentHead=currentHead.next;
		break;
	     }
	     prev=currentHead;
	     currentHead=currentHead.next;
	    }
	    if(currentHead.head==val)
	       prev.next=null;
	    this.size--;
	}
}
       singleLinkedList.prototype.search=function(val){
	       let currentHead=this.head;
	       if(currentHead.head==null)
		return;
	       else{
		     while(currentHead.next)
		       {
	         	 if(currentHead.head==val)
			  {
			    console.log(`Found val ${val}`);
			    break;
			  }
			 currentHead=currentHead.next;
		       }
		       if(currentHead.head==val && currentHead.next==null)
			console.log("Found at root");
	       }
       }
	singleLinkedList.prototype.deleteHead=function()
	{
		let currentElement=this.head;
		let popped=currentElement;
		if (currentElement.head==null)
			alert("Empty Linked List");
		else if(currentElement.next==null)
			currentElement.head=null;
		else
			currentElement.head=currentElement.next;
		console.log("element popped is "+popped.head);
		this.size--;
	}
	
	singleLinkedList.prototype.reverse=function()
	{
	  let currentElement=this.head;
	  let prev=null;
	  while(this.head)
	  {
	     let temp=this.head.next;
	     this.head.next=prev;
	     prev=this.head;
	     if(!temp)
		break;
	     this.head=temp;
	  }
	}
	singleLinkedList.prototype.duplicate=function()
	{
	   let buff={};
	   let currentElement=this.head;
	   let prev=null;
	   while(currentElement)
	   {
	     if(buff[currentElement.head])
	     {
		prev.next=currentElement.next;
		currentElement=currentElement.next;
		this.size--;
	     }
	     else
	     {
		buff[currentElement.head]=currentElement.head;
		prev=currentElement;
		currentElement=currentElement.next;
	     }
	   }
	}
        sll.insert(5);              //5->null
	sll.insert(10);             //10->5->null
	sll.insert(15);             //15->10->5->null
	sll.insert(20);     	    //20->15->10->5->null
	sll.deletion(5);	    //20->15->10->null
        sll.search(15);
        sll.deleteHead();           //15->10->null
	sll.insert(15);             //15->15->10->null
	sll.duplicate();            //15->10->null
        console.log(sll);
*/

/*
	//Implementation of doubly Linked List
	function Node(val)
	{
		this.head=val;             //this.head allows objects to 
		this.prev=null;		   //access the variables on its own
		this.next=null;		   //as let would return undefined
	}
	
	function doublyLinkedList()
	{
		this.head=null;
		this.size=0;
	}
	
	doublyLinkedList.prototype.insertAtHead=function(val)
	{
		if(this.head!=null)
		{
		   let temp=this.head;
		   this.head=new Node(val);
		   this.head.next=temp;
		   temp.prev=this.head;
		}
		else
		{   
		   this.head=new Node(val);
		   this.tail=this.head;
		}
		this.size++;
	}
	
	doublyLinkedList.prototype.insertAtTail=function(val)
	{
		if(this.tail==null)
		{
			this.tail=new Node(val);
			this.head=this.tail;
		}
		else
		{
			let temp=this.tail;
			this.tail=new Node(val);
			this.tail.prev=temp;
			temp.next=this.tail;
		}
		this.size++;
	}
	doublyLinkedList.prototype.deleteTail=function()
	{
		let currentTail=this.tail;
		if(this.tail===null)
		   console.log("Empty");
		else
		{
		   (this.tail).head=null;
		   this.tail=(this.tail).prev;
		   this.tail.next=null;
		}
		this.size--;
	}
	doublyLinkedList.prototype.deleteHead=function()
	{
		if(this.head==null)
		   console.log("Empty");
		else if(this.head==this.tail)
		   this.head=null;
		else
		{
		   (this.head).head=null;
		   this.head=(this.head).next;
		   (this.head.prev)=null;
		}
		this.size--;
	}
	doublyLinkedList.prototype.search=function(val)
	{
	   let currentNode=this.head;
	   while(currentNode)
	   {
	     if(currentNode.head==val)
		return(console.log("Found"));
	     currentNode=currentNode.next;
	   }
	   console.log("Not Found");
	}
	let dll=new doublyLinkedList();
	dll.insertAtHead(1);
	dll.insertAtHead(10);
	dll.insertAtHead(100);
	dll.insertAtTail(101);
	dll.deleteTail();
        dll.deleteHead();
	dll.search(10);
	console.log(dll);	   
*/



		            //Binary Search Tree

function BSTNode(value)
{
	this.value=value;
	this.left=null;
	this.right=null;
}

function BinarySearchTree()
{
	this._root=null;
}

BinarySearchTree.prototype.insert=function(value)
{
   let node=new BSTNode(value);
   if(!this._root)
	this._root=node;
   else
   {
     let currentNode=this._root;
     while(true)
     {
        if(currentNode.value>node.value)
        {
	   if(!currentNode.left)
	   {    
	     currentNode.left=node;
	     break;
	   }
	   currentNode=currentNode.left;
        }
	else if(node.value>currentNode.value)
	{
	   if(!currentNode.right)
	   {
	    currentNode.right=node;
	    break;
	   }
           currentNode=currentNode.right;
        }
        else
	   break;
    }
   }
}

BinarySearchTree.prototype.deletion=function(value)
{
   function findRightTreeMin(root)
   {
      while(root.left)
         root=root.left;
      return root;
   }

   function recursiveDeletion(root,value)
   {
	   
      if(!root)
	return null;
      else if(value<root.value)
      {
	 root.left=recursiveDeletion(root.left,value);
      }
      else if(value>root.value)
      {
	 root.right=recursiveDeletion(root.right,value);
      }
      else
      {
	 if(!root.left && !root.right)
	      return null;
	 else if(!root.left)
	      return root.right;
	 else if(!root.right)
	      return root.left;
	 else
	 {
	   let temp=findRightTreeMin(root.right);
	   root.value=temp.value;
	   root.right=recursiveDeletion(root.right,temp.value);
	 }
      }
      return root;
   }
   recursiveDeletion(this._root,value);
}

BinarySearchTree.prototype.search=function(value)
{
  let currentNode=this._root;
  while(currentNode)
  {
     if(value<currentNode.value)
        currentNode=currentNode.left;
     else if(value>currentNode.value)
	currentNode=currentNode.right;
     else
	return (console.log("Found"));
  }
  console.log("Not Found");
}
/*
let BST=new BinarySearchTree();
BST.insert(10);
BST.insert(4);
BST.insert(21);
BST.insert(5);
BST.insert(50);
BST.insert(3);
BST.insert(11);
BST.insert(40);
BST.insert(70);
BST.deletion(21);
BST.search(21);                        //Not Found
BST.search(4);                         //Found
console.log(BST);
*/

/*
				//LRU
function LRUNode(key,value)
{
   this.key=key;
   this.value=value;
   this.prev=null;
   this.next=null;
}
function LRUCache(capacity)
{
   this.keys={};                        //A hash table
   this.head=new LRUNode('',null);
   this.tail=new LRUNode('',null);
   this.capacity=capacity;
   this.head.next=this.tail;
   this.tail.prev=this.head;
}
LRUCache.prototype.addNode=function(node)
{
   let realTail=this.tail.prev;
   node.prev=realTail;
   realTail.next=node;
   node.next=this.tail;
   this.tail.prev=node;
}
LRUCache.prototype.delNode=function(node)
{
   let prevNode=node.prev;
   let nextNode=node.next;
   prevNode.next=nextNode;
   nextNode.prev=prevNode;
}
LRUCache.prototype.set=function(key,value)
{
   let node=this.keys[key];
   
   if(node)
      this.delNode(node);
   
   node=new LRUNode(key,value);
   this.keys[key]=node;
   this.addNode(node);
   if(this.capacity<Object.keys(this.keys).length)
   {
      let realHead=this.head.next;
      this.delNode(realHead);
      delete this.keys[realHead.key];
   }
}
LRUCache.prototype.get=function(key)
{
   let node=this.keys[key];
   if(node==undefined)
      return null;
   else
   {
      this.delNode(node);
      this.addNode(node);
      return node.value;
   }
}
let myLRU=new LRUCache(5);
myLRU.set(1,1);				//1
myLRU.set(2,'b');			//1<->b
myLRU.set(3,3);				//1<->b<->3
myLRU.set(4,4);				//1<->b<->3<->4
myLRU.set(5,'e');			//1<->b<->3<->4<->e
myLRU.set(6,'f');			//b<->3<->4<->e<->f
myLRU.set(7,7);				//3<->4<->5<->f<->7
console.log(myLRU);
myLRU.get(4);				//3<->5<->f<->7<->4
myLRU.get(12);
*/

/*
			      //HASH TABLES
function hashTable(size)
{
   this.size=size;
   this.keys=new Array(size).fill(null);
   this.values=new Array(size).fill(null);
   this.limit=0;
}
*/

/*
  			//Linear probing method
hashTable.prototype.put=function(key,value)
{
   if(this.size<=this.limit)
      throw "OVERFLOW";
   let hashedIndex=this.hash(key);
   while(this.keys[hashedIndex]!=null)
   {
      hashedIndex++;
      hashedIndex=this.hash(hashedIndex);
   }
   this.keys[hashedIndex]=key;
   this.values[hashedIndex]=value;
   this.limit++;
}
				
hashTable.prototype.get=function(key)
{
   let hashedIndex=key % this.size;
   while(this.keys[hashedIndex]!=null && this.keys[hashedIndex]!=key)
   {
      hashedIndex++;
      hashedIndex=this.hash(hashedIndex);
   }
   return this.values[hashedIndex];
}
hashTable.prototype.hash=function(key)
{
   return key % this.size;
}
*/

/*
                           //Quadratic probing
hashTable.prototype.put=function(key,value)
{
   let squareNo=0;
   if(this.size<=this.limit)
      throw "OVERFLOW";
   let hashedIndex=this.hash(key);
   while(this.keys[hashedIndex]!=null)
   {
      squareNo++;
      hashedIndex=hashedIndex + Math.pow(squareNo,2);
      hashedIndex=this.hash(hashedIndex);
   }
   this.keys[hashedIndex]=key;
   this.values[hashedIndex]=value;
   this.limit++;
}
				
hashTable.prototype.get=function(key)
{
   let squareNo=0;
   let hashedIndex=key % this.size;
   while(this.keys[hashedIndex]!=null && this.keys[hashedIndex]!=key)
   {
      squareNo++;
      hashedIndex=hashedIndex + Math.pow(squareNo,2);
      hashedIndex=this.hash(hashedIndex);
   }
   return this.values[hashedIndex];
}
hashTable.prototype.hash=function(key)
{
   return key % this.size;
}
let hT=new hashTable(7);
hT.put(4,'a');
hT.put(11,'b');
hT.put(15,3);
hT.put(18,4);
console.log(hT.get(11));
console.log(hT);
*/
/*
				//In-order Traversal
BinarySearchTree.prototype.inOrder=function()
{
   function traverser(node)
   {
      if(!node)
         return;
      traverser(node.left);
      console.log(node.value);
      traverser(node.right);
   }
   traverser(this._root);
}
			//Pre-Order Traversal
BinarySearchTree.prototype.preOrder=function()
{
   function preOrderTraversal(node)
   {
      if(!node)
         return;
      console.log(node.value);
      preOrderTraversal(node.left);
      preOrderTraversal(node.right);
   }
   preOrderTraversal(this._root);
}
			//Post-order traversal
BinarySearchTree.prototype.postOrder=function()
{
   function postOrderTraversal(node)
   {
      if(!node)
	return;
      postOrderTraversal(node.right);
      postOrderTraversal(node.left);
      console.log(node.value);
   }
   postOrderTraversal(this._root);
}
BinarySearchTree.prototype.levelOrder=function()
{
   function levelOrderTraversal(node)
   {
      let Q=[];
      Q.push(node);
      while(Q.length)
      {
         node=Q.shift();
	 console.log(node.value);
	 if(node.left)
	   Q.push(node.left)
	 if(node.right)
	   Q.push(node.right);
      }
   }
   levelOrderTraversal(this._root);
}
let traversalBST=new BinarySearchTree();
let nodeValues=[20,14,4,17,29,24,31,7,3];
nodeValues.map((val,i)=>traversalBST.insert(val));
traversalBST.preOrder();		// [20,14,4,3,7,17,29,24,31]
traversalBST.inOrder();			// [3,4,7,14,17,20,24,29,31]
traversalBST.postOrder();		// [3,7,4,17,14,24,31,29,20]
traversalBST.levelOrder();		// [20,14,29,4,17,24,31,3,7]
*/

				//Graphs

/*
				//Undirected Graphs	
function unDirectedGraphs()
{
   this.edges={};
}

unDirectedGraphs.prototype.addVertex=function(vertex)
{
   this.edges[vertex]={};
}

unDirectedGraphs.prototype.addEdge=function(vertex1,vertex2,weight=0)
{
   this.edges[vertex1][vertex2]=weight;
   this.edges[vertex2][vertex1]=weight;
}

unDirectedGraphs.prototype.removeEdge=function(vertex1,vertex2)
{
   delete this.edges[vertex1][vertex2];
   delete this.edges[vertex2][vertex1];
}

unDirectedGraphs.prototype.removeVertex=function(RIPVertex)
{
   for(Adjvertices in this.edges[RIPVertex])
   {
      this.removeEdge(RIPVertex,Adjvertices);
   }
   delete this.edges[RIPVertex];
}

unDirectedGraphs.prototype.BFS=function(vertex)
{
   let Q=[];
   let count=0;
   let checked={};
   Q.push(vertex);
   while(Q.length)
   {
      console.log("Count is "+count);
      count++;
      let vertex=Q.shift();
      if(!checked[vertex])
      {
         console.log(vertex);
	 checked[vertex]=true;
	 for(adjVertex in this.edges[vertex])
	 {
	    Q.push(adjVertex);
	 }
      }
   }
}

unDirectedGraphs.prototype.DFS=function(vertex,visited={})
{
   console.log("The visited is "+JSON.stringify(visited))
   visited[vertex]=true;
   console.log(vertex);
   for(adjVertex in this.edges[vertex])
   {
     if(!visited[adjVertex])
	this.DFS(adjVertex,visited);
   }
   console.log("Visited is "+JSON.stringify(visited));
}

unDirectedGraphs.prototype.Dijkstra=function(source)
{
   function isEmpty(Vcopy)
   {
      return(Object.keys(Vcopy)==0);
   }

   function findMin(Vcopy,distances)
   {
      let minDist=Infinity;
      let minDistVertex=Infinity;
      for(vertex in Vcopy)
      {
	 if(distances[vertex]<minDist)
	 {
	    minDist=distances[vertex];
	    minDistVertex=vertex;
	 }
      }
      return minDistVertex;
   }
 let Vcopy={},distances={};
 for(vertex in this.edges)
 {
    Vcopy[vertex]=this.edges[vertex];
    distances[vertex]=Infinity;
 }
 distances[source]=0;
 while(!isEmpty(Vcopy))
 {
    let nearestV=findMin(Vcopy,distances);
    delete Vcopy[nearestV];

    for(neighbour in this.edges[nearestV])
    {
       let alt=distances[nearestV]+this.edges[nearestV][neighbour];
       if(alt<distances[neighbour])
	  distances[neighbour]=alt;
    }
 }
 console.log(distances);
}
*/

/*
let graph=new unDirectedGraphs();
graph.addVertex(1);
graph.addVertex(2);
graph.addVertex(3);
graph.addVertex(4);
graph.addVertex(5);
graph.addEdge(1,2);
graph.addEdge(2,3,8);
graph.addEdge(3,4,10);
graph.addEdge(4,5,100);
graph.addEdge(1,5,88);
graph.removeVertex(1);
console.log(graph);
*/

/*	
let DijkstrasGraph=new unDirectedGraphs();
['A','B','C','D','E'].map((v,i)=>DijkstrasGraph.addVertex(v));
DijkstrasGraph.addEdge('A','B',12);
DijkstrasGraph.addEdge('A','C',8);
DijkstrasGraph.addEdge('A','D',33);
DijkstrasGraph.addEdge('B','E',8);
DijkstrasGraph.addEdge('C','E',21);
DijkstrasGraph.addEdge('D','E',1);
DijkstrasGraph.Dijkstra('A');		//{A:0,B:12,C:8,D:21,E:20}
*/

/*
let BFSgraph=new unDirectedGraphs();
[1,2,3,4,5].map((v,i)=>BFSgraph.addVertex(v));
BFSgraph.addEdge(1,2);
BFSgraph.addEdge(1,4);
BFSgraph.addEdge(2,3);
BFSgraph.addEdge(4,5);
BFSgraph.addEdge(3,5);
BFSgraph.DFS(1);				//[1,2,3,5,4]
BFSgraph.BFS(1);				//[1,2,4,3,5]
*/

/*
			//Directed Graphs
function DirectedGraphs()
{
   this.edges={};
}
DirectedGraphs.prototype.addVertex=function(vertex)
{
   this.edges[vertex]={};
}
DirectedGraphs.prototype.addEdges=function(origVertex,destVertex,weight=0)
{
   this.edges[origVertex][destVertex]=weight;
}
DirectedGraphs.prototype.removeEdges=function(origVertex,destVertex)
{
if(this.edges[origVertex] && this.edges[origVertex][destVertex]!=undefined)
   delete this.edges[origVertex][destVertex];
}
DirectedGraphs.prototype.removeVertex=function(vertex)
{
  for(destVertices in this.edges[vertex])
   {
     this.removeEdges(vertex,destVertices);
   }
  delete this.edges[vertex];
}
DirectedGraphs.prototype.BreadthFirstSearch=function(vertex)
{
   let Q=[];
   let visited={};
   Q.push(vertex);
   while(Q.length)
   {
      let value=Q.shift();
      if(!visited[value])
      {
         console.log(value);
	 visited[value]=true;
         for(destVertices in this.edges[value])
         Q.push(destVertices);
      }
   }
}
DirectedGraphs.prototype.DFS=function(vertex,visited={})
{
   console.log(vertex);
   visited[vertex]=true;
   for(adjVertex in this.edges[vertex])
   {
      if(!visited[adjVertex])
	 this.DFS(adjVertex,visited);
   }
}
DirectedGraphs.prototype.Dijkstra=function(vertex)
{
   function isEmpty(Q)
   {
     return (Object.keys(Q).length===0);
   }
   
   function findMin(Q,dist)
   {
      let minDist=Infinity;
      let minDistNode=null;
      
      for(adjVertex in Q)
      {
	if(dist[adjVertex]<=minDist)
	{
	   minDist=dist[adjVertex];
	   minDistNode=adjVertex;
	}
      }
      return minDistNode;
    }
       let Q={},dist={};
       for(vertices in this.edges)
       {
	  Q[vertices]=this.edges[vertices];
	  dist[vertices]=Infinity;
       }
       dist[vertex]=0;
       while(!isEmpty(Q))
       {
	  let u=findMin(Q,dist);
	  delete Q[u];
	 
          for(neighbour in this.edges[u])
	  {
	    let alt=dist[u]+this.edges[u][neighbour];
	    if(alt<dist[neighbour])
	      dist[neighbour]=alt;
	  }
       }
       console.log(dist);
    
}
	
*/

/*
let Dgraph=new DirectedGraphs();
Dgraph.addVertex('A');
Dgraph.addVertex('B');
Dgraph.addVertex('C');
Dgraph.addEdges('A','B',12);
Dgraph.addEdges('B','C');
Dgraph.addVertex('D');
Dgraph.addVertex('E');
Dgraph.addVertex('F');
Dgraph.addVertex('G');
Dgraph.addVertex('H');
Dgraph.addVertex('I');
Dgraph.addEdges('B','D',22);
Dgraph.addEdges('D','I');
Dgraph.addEdges('C','E');
Dgraph.addEdges('C','F',19);
Dgraph.addEdges('C','G');
Dgraph.addEdges('C','H');
Dgraph.addEdges('H','A');
//Dgraph.removeVertex('A');
console.log(Dgraph);
Dgraph.BreadthFirstSearch('A');
*/

/*
let D2Graph=new DirectedGraphs();
[1,2,3,4,5].map((v,i)=>D2Graph.addVertex(v));
D2Graph.addEdges(1,2);
D2Graph.addEdges(1,3);
D2Graph.addEdges(2,4);
D2Graph.addEdges(3,5);
D2Graph.DFS();					//[1,2,4,3,5]
D2Graph.BreadthFirstSearch(1);			//[1,2,3,4,5]
*/

/*	
['A','B','C','D','E'].map((v,i)=>D2Graph.addVertex(v));	
D2Graph.addEdges('A','B',12);
D2Graph.addEdges('A','C',15);
D2Graph.addEdges('A','D',7);
D2Graph.addEdges('B','E',4);
D2Graph.addEdges('D','E',19);
D2Graph.addEdges('C','E',4);
D2Graph.Dijkstra('A');				//{A:0,B:12,C:15,D:7,E:16}
*/
/*
					//Heaps

function Heap()
{
   let heapArr=[];
}

Heap.prototype.swap=function(index1,index2)
{
   let temp=this.heapArr[index1];
   this.heapArr[index1]=this.heapArr[index2];
   this.heapArr[index2]=temp;
}

Heap.prototype.parentIndex=function(N)
{
   return Math.floor((N-1)/2);
}

Heap.prototype.parent=function(N)
{
   return this.heapArr[this.parentIndex(N)];
}

Heap.prototype.leftChildIndex=function(N)
{
   return (N*2)+1;
}

Heap.prototype.leftChild=function(N)
{
   return this.heapArr[this.leftChildIndex(N)];
}

Heap.prototype.rightChildIndex=function(N)
{
   return (N*2)+2;
}

Heap.prototype.rightChild=function(N)
{
   return this.heapArr[this.rightChildIndex(N)];
}
*/

/*
						//Min-Heap
function MinHeap()
{
   this.heapArr=[];
}

MinHeap.prototype=Object.create(Heap.prototype);

MinHeap.prototype.bubbleUp=function()
{
   let index=this.heapArr.length-1;
   while(this.parent(index) && this.parent(index)>this.heapArr[index])
   {
      this.swap(this.parentIndex(index),index);
      index=this.parentIndex(index);
   }
}

MinHeap.prototype.bubbleDown=function()
{
   let index=0;
   while(this.leftChild(index) && 
	 this.leftChild(index)<this.heapArr[index] || 
	 this.rightChild(index)<this.heapArr[index])
   {
      let small=this.leftChildIndex(index);
      if(this.rightChild(index) && this.leftChild(index)>this.rightChild(index))
         small=this.rightChildIndex(index);
      this.swap(index,small)
      index=small;
   }
}

MinHeap.prototype.add=function(item)
{
   if(this.heapArr.indexOf(item)!=-1)
      return;
   this.heapArr[this.heapArr.length]=item;
   this.bubbleUp();
}

MinHeap.prototype.poll=function()
{
   let element=this.heapArr[0];
   this.heapArr[0]=this.heapArr.pop();
   console.log(element);
   this.bubbleDown();
}

let minHeap=new MinHeap();
[1,1,2,5,4,3,6,8,7].map((v,i)=>minHeap.add(v));
console.log(minHeap);					
minHeap.poll();							//1
minHeap.poll();							//2
minHeap.poll();							//3
minHeap.poll();							//4
*/						
/*
						//Max-Heap

function MaxHeap()
{
   this.heapArr=[];
}

MaxHeap.prototype=Object.create(Heap.prototype);

MaxHeap.prototype.bubbleUp=function()
{
   let index=this.heapArr.length-1;
   while(this.parent(index) && this.parent(index)<this.heapArr[index])
   {
      this.swap(this.parentIndex(index),index);
      index=this.parentIndex(index);
   }
}

MaxHeap.prototype.bubbleDown=function()
{
   let index=0;
   while(this.leftChild(index) && 
	 this.leftChild(index)>this.heapArr[index] || 
	 this.rightChild(index)>this.heapArr[index])
   {
      let big=this.leftChildIndex(index);
      if(this.rightChild(index) && this.leftChild(index)<this.rightChild(index))
         big=this.rightChildIndex(index);
      this.swap(index,big)
      index=big;
   }
}

MaxHeap.prototype.add=function(item)
{
   if(this.heapArr.indexOf(item)!=-1)
      return;
   this.heapArr[this.heapArr.length]=item;
   this.bubbleUp();
}

MaxHeap.prototype.poll=function()
{
   let element=this.heapArr[0];
   this.heapArr[0]=this.heapArr.pop();
   console.log(element);
   this.bubbleDown();
}

let maxHeap=new MaxHeap();
[1,2,3,4,4,5,3,6,7].map((v,i)=>maxHeap.add(v));
maxHeap.poll();							//7
maxHeap.poll();							//6
maxHeap.poll();							//5
*/   
/*
				//Insertion-Sort(Ascending-order)
function insertionSort(A)
{
   let arr=[...A];
   for(let i=1;i<arr.length;i++)
   {
      let curntVal=arr[i];
      let j=i-1;
      while(j>=0 && arr[j]>curntVal)
      {
	arr[j+1]=arr[j];
	j--;
      }
      arr[j+1]=curntVal;
   }
   return arr;
}

console.log(insertionSort([7,1,2,0,6,9]));
*/
/*

				//BubbleSort(Ascending order)
function bubbleSort(A)
{
   let arr=[...A];
   for(let i=0;i<arr.length-1;i++)
   {
      for(let j=0;j<arr.length-1;j++)
      {
         if(arr[j]>arr[j+1])
	   [arr[j],arr[j+1]]=[arr[j+1],arr[j]];
      }
   }
   return arr;
}

console.log(bubbleSort([1,4,0,8,11,-2]));
*/
/*

				//Quicksort
function quickSort(A)
{
   let arr=[...A];
   if(arr.length<=1)
      return arr;
   let leftArr=[];
   let rightArr=[];
   let pivotElement=arr.shift();
   let centralArr=[pivotElement];
   while(arr.length)
   {
      let currentElement=arr.shift();
      if(currentElement>pivotElement)
	rightArr.push(currentElement);
      else if(currentElement<pivotElement)
	leftArr.push(currentElement);
      else
	centralArr.push(currentElement);
   }
   leftArr=quickSort(leftArr);
   rightArr=quickSort(rightArr);
   return leftArr.concat(centralArr,rightArr);
}

console.log(quickSort([6,4,9,1]));
*/

/*
				//Merge-Sort
function mergeSort(A)
{
   let arr=[...A];
   if(arr.length<=1)
      return arr;
   let mid=Math.floor(arr.length/2);
   return merge(mergeSort(arr.splice(0,mid)),mergeSort(arr));
}

function merge(leftArr,rightArr)
{
   let arr=[];
   while(leftArr.length && rightArr.length)
   {
      if(leftArr[0]<rightArr[0])
	 arr.push(leftArr.shift());
      else
	 arr.push(rightArr.shift());
   }
   
   return arr.concat(leftArr,rightArr);
}

console.log(mergeSort([2,2,1,0,6]));
*/
/*
				//Count-sort

function countSort(A)
{
   let arr=[...A];
   let dict={};
   /*
   for(let i=0;i<arr.length;i++)
   {
      if(!dict[arr[i]])
	 dict[Number(arr[i])]=1;
      else
	 ++dict[arr[i]];
   }
   arr=[];
   */
   /*
   while(arr.length)
   {
      currentElement=arr.shift();
      if(!dict[currentElement])
	 dict[Number(currentElement)]=1;
      else
	 dict[currentElement]++;
   }
   for(key in dict)
   {
     for(i=0;i<dict[key];i++)
       arr.push(key);
   }
   return arr;
}


console.log(countSort([2,8,2,2,2,6,1,0]));
*/
</script>
</body>
</html>
